#include "UartCommondServe.h"
/* FreeRTOS+CLI includes. */
#include "FreeRTOS_CLI.h"
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include <string.h>
#include "usart.h"

extern void vCreateAndVerifySampleFiles( void );

/* Dimensions the buffer into which input characters are placed. */
#define cmdMAX_INPUT_SIZE	60

/* Dimensions the buffer into which string outputs can be placed. */
#define cmdMAX_OUTPUT_SIZE	1024

/* Dimensions the buffer passed to the recvfrom() call. */
#define cmdSOCKET_INPUT_BUFFER_SIZE 60

/* DEL acts as a backspace. */
#define cmdASCII_DEL		( 0x7F )

extern QueueHandle_t Message_Queue;	//信息队列句柄




void vUARTCommandInterpreterTask( void *pvParameters )
{
	long lBytes, lByte;
	char cInChar, cInputIndex = 0;
	char cInputString[ cmdMAX_INPUT_SIZE ], cOutputString[ cmdMAX_OUTPUT_SIZE ];
	BaseType_t xMoreDataToFollow;
	volatile int iErrorCode = 0;
	u8 *buffer;
	BaseType_t err;
	
	memset(cInputString,0,cmdMAX_INPUT_SIZE);	//清除缓冲区
	buffer=pvPortMalloc(USART_REC_LEN);
	/* Just to prevent compiler warnings. */
	( void ) pvParameters;

	vCreateAndVerifySampleFiles();
	for( ;; )
	{
		if(Message_Queue!=NULL)
		{
			memset(buffer,0,USART_REC_LEN);	//清除缓冲区
			err=xQueueReceive(Message_Queue,buffer,portMAX_DELAY);//请求消息Message_Queue
			if(err==pdTRUE)			//接收到消息
			{
				lBytes = strlen((const char *)buffer);
				/* Process each received byte in turn. */
				lByte = 0;
				while( lByte < lBytes )
				{
					/* The next character in the input buffer. */
					cInChar = buffer[ lByte ];
					lByte++;

					/* Newline characters are taken as the end of the command
					string. */
					if( cInChar == '\n' )
					{
						/* Process the input string received prior to the
						newline. */
						do
						{
							/* Pass the string to FreeRTOS+CLI. */
							xMoreDataToFollow = FreeRTOS_CLIProcessCommand( cInputString, cOutputString, cmdMAX_OUTPUT_SIZE );

							/* Send the output generated by the command's
							implementation. */
							//UartSendto(  cOutputString, strlen( cOutputString ) );
							Computer_485_ModeTx();
							printf("%s",cOutputString);
							Computer_485_ModeRx();

						} while( xMoreDataToFollow != pdFALSE ); /* Until the command does not generate any more output. */

						/* All the strings generated by the command processing
						have been sent.  Clear the input string ready to receive
						the next command. */
						cInputIndex = 0;
						memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );

						/* Transmit a spacer, just to make the command console
						easier to read. */
						Computer_485_ModeTx();
						printf( "\r\n" );
						Computer_485_ModeRx();
					}
					else
					{
						if( cInChar == '\r' )
						{
							/* Ignore the character.  Newlines are used to
							detect the end of the input string. */
						}
						else if( ( cInChar == '\b' ) || ( cInChar == cmdASCII_DEL ) )
						{
							/* Backspace was pressed.  Erase the last character
							in the string - if any. */
							if( cInputIndex > 0 )
							{
								cInputIndex--;
								cInputString[ cInputIndex ] = '\0';
							}
						}
						else
						{
							/* A character was entered.  Add it to the string
							entered so far.  When a \n is entered the complete
							string will be passed to the command interpreter. */
							if( cInputIndex < cmdMAX_INPUT_SIZE )
							{
								cInputString[ cInputIndex ] = cInChar;
								cInputIndex++;
							}
						}
					}
				}
			}
		}
	}
}

